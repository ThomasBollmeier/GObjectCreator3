/*
 * ...Copyright/Licensing information...
 */
 
:> if [ not is_empty(class.module) ] then begin
#ifndef __${MODULE_PREFIX}_${CLASS_NAME}_H__
#define __${MODULE_PREFIX}_${CLASS_NAME}_H__
:> else
#ifndef __${CLASS_NAME}_H__
#define __${CLASS_NAME}_H__
:> endif

G_BEGIN_DECLS

#include <glib-object.h>

:> if [ not is_empty(class.super_class) ] then begin
#include "${filename_wo_suffix(class.super_class)}.h"
:> endif
:> for each intf in class.interfaces do
#include "${filename_wo_suffix(intf)}.h"
:> done

:> edit-section 'top' begin
/* insert further includes here... */
:> endedit

:> if [ not is_empty(MODULE_PREFIX) ] then begin
#define ${MODULE_PREFIX}_TYPE_${CLASS_NAME}            (${class_prefix}_get_type ())
#define ${MODULE_PREFIX}_${CLASS_NAME}(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), ${MODULE_PREFIX}_TYPE_${CLASS_NAME}, ${FullClassName}))
#define ${MODULE_PREFIX}_IS_${CLASS_NAME}(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ${MODULE_PREFIX}_TYPE_${CLASS_NAME}))
#define ${MODULE_PREFIX}_${CLASS_NAME}_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), ${MODULE_PREFIX}_TYPE_${CLASS_NAME}, ${FullClassName}Class))
#define ${MODULE_PREFIX}_IS_${CLASS_NAME}_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ${MODULE_PREFIX}_TYPE_${CLASS_NAME}))
#define ${MODULE_PREFIX}_${CLASS_NAME}_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), ${MODULE_PREFIX}_TYPE_${CLASS_NAME}, ${FullClassName}Class))
:> else
#define TYPE_${CLASS_NAME}            (${class_prefix}_get_type ())
#define ${CLASS_NAME}(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_${CLASS_NAME}, ${ClassName}))
#define IS_${CLASS_NAME}(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_${CLASS_NAME}))
#define ${CLASS_NAME}_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_${CLASS_NAME}, ${ClassName}Class))
#define IS_${CLASS_NAME}_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_${CLASS_NAME}))
#define ${CLASS_NAME}_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_${CLASS_NAME}, ${ClassName}Class))
:> endif

typedef struct _${FullClassName}      ${FullClassName};
typedef struct _${FullClassName}Class ${FullClassName}Class;

:> define hasPrivAttrs = FALSE
:> define hasProtAttrs = FALSE
:> define hasPrivClassAttrs = FALSE
:> define hasProtClassAttrs = FALSE
:> for each a in class.get_attributes() do
	:> case a.visibility in
	:> PRIVATE)
		:> if [ not a.is_static ] then begin
			:> hasPrivAttrs = TRUE
		:> else
			:> hasPrivClassAttrs = TRUE
		:> endif
	:> PROTECTED)
		:> if [ not a.is_static ] then begin
			:> hasProtAttrs = TRUE
		:> else
			:> hasProtClassAttrs = TRUE
		:> endif
	:> endcase
:> done
:> if [ hasProtAttrs ] then begin
typedef struct _${FullClassName}Protected ${FullClassName}Protected;
:> endif
:> if [ hasPrivAttrs ] then begin
typedef struct _${FullClassName}Private ${FullClassName}Private;
:> endif
:> if [ hasProtClassAttrs ] then begin
typedef struct _${FullClassName}ClsProtected ${FullClassName}ClsProtected;
:> endif
:> if [ hasPrivClassAttrs ] then begin
typedef struct _${FullClassName}ClsPrivate ${FullClassName}ClsPrivate;
:> endif

struct _${FullClassName}
{

	:> if [ is_empty(class.super_class) ] then begin
	GObject super;
	:> else
	${type_name(class.super_class)} super;
	:> endif

	:> if [ hasProtAttrs ] then begin
	${FullClassName}Protected *prot; /* protected attributes */
	:> endif	
	:> if [ hasPrivAttrs ] then begin
	${FullClassName}Private *priv; /* private attributes */
	:> endif	

};

struct _${FullClassName}Class
{

	:> if [ is_empty(class.super_class) ] then begin
  	GObjectClass super_class;
  	:> else
  	${type_name(class.super_class)}Class super;
  	:> endif

  	/* class members */

	:> if [ hasProtClassAttrs ] then begin
	${FullClassName}ClsProtected *prot; /* protected attributes */
	:> endif	
	:> if [ hasPrivClassAttrs ] then begin
	${FullClassName}ClsPrivate *priv; /* private attributes */
	:> endif	
  	
};

GType 
${class_prefix}_get_type (void);

:> define suppress_param_names = FALSE
:> define insert_line_breaks = TRUE
:> define indent_level = 1

:> if [ not class.is_abstract ] then begin
/* 
 * constructor: 
 */
${FullClassName} *
	:> if [ not is_empty(class.constructor) ] then begin
${class_prefix}_new (${method_signature(class, class.constructor, suppress_param_names, insert_line_breaks, indent_level)});
	:> else
${class_prefix}_new (void);
	:> endif
:> endif
 
:> for each method in class.methods where method.visibility == PUBLIC do
	:> if [ isFirst ] then begin
/*
 * public methods:
 */
 	
 	:> endif	
${method_result(method)}
${class_prefix}_${method.name} (${method_signature(class, method, suppress_param_names, insert_line_breaks, indent_level)});   	

:> done

G_END_DECLS

:> if [ not is_empty(MODULE_PREFIX) ] then begin
#endif /* __${MODULE_PREFIX}_${CLASS_NAME}_H__ */
:> else
#endif /* __${CLASS_NAME}_H__ */
:> endif
