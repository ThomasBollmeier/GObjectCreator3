:> if [ class.has_protected_members() or not class.is_final ] then begin
#include "${protected_header(class)}"
:> else
#include "${filename_wo_suffix(class)}.h"
	:> if [ not is_empty(class.super_class) ] then begin
#include "${protected_header(class.super_class)}"
	:> endif
:> endif
:> if [ class.has_signals() ] then begin
#include "${marshaller_header(class)}"
#include <stdarg.h>
:> endif

:> edit-section 'source-top' begin
/* ... */
:> endedit

:> define supress_param_names = FALSE
:> define insert_line_breaks = TRUE
:> define indent_level = 1

:> define hasPrivAttrs = FALSE
:> define hasPrivClassAttrs = FALSE
:> define hasProtAttrs = FALSE
:> define hasProtClassAttrs = FALSE
:> for each a in class.get_attributes() do
	:> case a.visibility in
	:> PROTECTED)
		:> if [ not a.is_static ] then begin
			:> hasProtAttrs = TRUE
		:> else
			:> hasProtClassAttrs = TRUE
		:> endif
	:> PRIVATE)
		:> if [ not a.is_static ] then begin
			:> hasPrivAttrs = TRUE
		:> else
			:> hasPrivClassAttrs = TRUE
		:> endif
	:> endcase
:> done

:> if [ hasPrivAttrs ] then begin
struct _${FullClassName}Private  
{
:> for each attr in class.get_attributes() where \
	attr.visibility == PRIVATE and \
	attr.is_static == FALSE \
	do
	${rearrange_asterisk(type_name(attr.type, TRUE), attr.name)};
:> done
};

# define ${CAST_MACRO(class)}_GET_PRIVATE(obj) \
	(G_TYPE_INSTANCE_GET_PRIVATE ((obj), ${TYPE_MACRO(class)}, ${FullClassName}Private))
:> endif

:> if [ hasPrivClassAttrs ] then begin
struct _${FullClassName}ClsPrivate 
{
:> for each attr in class.get_attributes() where \
	attr.visibility == PRIVATE and \
	attr.is_static == TRUE \
	do
	${rearrange_asterisk(type_name(attr.type, TRUE), attr.name)};
:> done
}
:> endif

/* 
 * Global variables to access current class and its parent. 
 * Will be set in class_init. 
 */ 
static ${FullClassName}Class *${class_prefix}_class = NULL;
static GObjectClass *${class_prefix}_parent_class = NULL; 

:> if [ not is_empty(class.get_properties()) ] then begin

enum 
{
	PROP_0,
	:> for each prop in class.get_properties() do
	${PROP_NAME(prop)},
	:> done
	NUM_PROPERTIES
};

static GParamSpec *${class_prefix}_properties[NUM_PROPERTIES] = {NULL, };

:> endif

:> if [ class.has_signals() ] then begin

enum
{
	:> for each signal in class.get_signals() do
	SIGNAL_${to_upper(signal_tech_name(signal))},
	:> done
	NUM_SIGNALS
};

static guint ${class_prefix}_signals[NUM_SIGNALS];

static guint
${class_prefix}_register_signal (
	const gchar *signal_name,
	GClosure *default_closure,
	GSignalCMarshaller marshaller,
	GType return_type,
	guint num_params,
	...
	)
{
	va_list args;
	
	va_start (args, num_params);
		
	return g_signal_new_valist (
		signal_name,
		${TYPE_MACRO(class)},
		G_SIGNAL_RUN_LAST|G_SIGNAL_DETAILED,
		default_closure,
		NULL, /* accumulator */
		NULL, /* accumulator data */
		marshaller,
		return_type,
		num_params,
		args
		);
		
	va_end (args);

} 

	:> for each signal in class.get_signals() do

static void 
${class_prefix}_on_${signal_tech_name(signal)} (${method_signature(class, signal, FALSE, TRUE, 1, "sender")})
{
	:> define section_name = signal_section_defhandler(signal)
	:> edit-section section_name begin 
	// insert implementation of default signal handler for signal "${signal.name}"
	:> endedit 
}

	:> done

:> endif

static void 
${class_prefix}_base_init (gpointer klass)
{

:> edit-section 'base-init' begin
/* Add custom base initialization code ... */
:> endedit

}

static void 
${class_prefix}_base_finalize (gpointer klass)
{

:> edit-section 'base-finalize' begin
/* Add custom base finalization code ... */
:> endedit

}

static GObject *
${class_prefix}_constructor (
	GType gtype,
	guint num_properties,
	GObjectConstructParam *properties
	);
	
static void
${class_prefix}_dispose (GObject* obj);

static void
${class_prefix}_finalize (GObject* obj);
	
:> if [ not is_empty(class.get_properties()) ] then begin

static void
${class_prefix}_set_property (
	GObject      *object,
	guint        property_id,
	const GValue *value,
	GParamSpec   *pspec
	);
	
static void
${class_prefix}_get_property (
	GObject    *object,
	guint      property_id,
	GValue     *value,
	GParamSpec *pspec
	);

:> endif

static void                
${class_prefix}_class_init (
	gpointer klass,
	gpointer class_data
	)
{

	GObjectClass *gobj_class;
	:> if [ class.has_signals() ] then begin
	GClosure *closure;
	:> endif

	/* set global pointers to class and its parent: */ 
:> if [ not is_empty(MODULE_PREFIX) ] then begin
	${class_prefix}_class = ${MODULE_PREFIX}_${CLASS_NAME}_CLASS (klass);
:> else
	${class_prefix}_class = ${CLASS_NAME}_CLASS (klass);
:> endif
	${class_prefix}_parent_class = g_type_class_peek_parent (${class_prefix}_class);
	gobj_class = G_OBJECT_CLASS (${class_prefix}_class);
	
	gobj_class->constructor = ${class_prefix}_constructor;
	gobj_class->dispose = ${class_prefix}_dispose;
	gobj_class->finalize = ${class_prefix}_finalize;

:> for each signal in class.get_signals() do 
	:> if [ isFirst ] then begin
	/* default handlers for signals: */
	:> endif
	${class_prefix}_class->${signal_tech_name(signal)} = ${class_prefix}_on_${signal_tech_name(signal)};
:> done 
	
:> if [ hasPrivAttrs ] then begin
	/* register structure that contains private attributes: */
	g_type_class_add_private (klass, sizeof (${FullClassName}Private));
:> endif

:> if [ not is_empty(class.get_properties()) ] then begin

	/* setter and getter for properties: */
	gobj_class->set_property = ${class_prefix}_set_property;
	gobj_class->get_property = ${class_prefix}_get_property;
	
	:> for each prop in class.get_properties() do
	
	:> edit-section prop.name begin
		:> case prop.type in
			:> PropType.BOOLEAN)
	${class_prefix}_properties[${PROP_NAME(prop)}] = g_param_spec_boolean (
		"${prop.name}",
		"${prop.name}",
		"${literal_trim(prop.description)}",
		:> if [ not is_empty(prop.default) ] then begin
		${prop_value(prop.default)},
		:> else
		FALSE,
		:> endif
		${prop_flags(prop)}|G_PARAM_STATIC_STRINGS
		);
			:> PropType.BYTE)
	${class_prefix}_properties[${PROP_NAME(prop)}] = g_param_spec_uchar (
		"${prop.name}",
		"${prop.name}",
		"${literal_trim(prop.description)}",
		:> if [ not is_empty(prop.min) ] then begin
		${prop_value(prop.min)},
		:> else
		0,
		:> endif	
		:> if [ not is_empty(prop.max) ] then begin
		${prop_value(prop.max)},
		:> else
		255,
		:> endif	
		:> if [ not is_empty(prop.default) ] then begin
		${prop_value(prop.default)},
		:> else
		0,
		:> endif
		${prop_flags(prop)}|G_PARAM_STATIC_STRINGS	
		);
			:> PropType.INTEGER)
	${class_prefix}_properties[${PROP_NAME(prop)}] = g_param_spec_int (
		"${prop.name}",
		"${prop.name}",
		"${literal_trim(prop.description)}",
		:> if [ not is_empty(prop.min) ] then begin
		${prop_value(prop.min)},
		:> else
		G_MININT,
		:> endif	
		:> if [ not is_empty(prop.max) ] then begin
		${prop_value(prop.max)},
		:> else
		G_MAXINT,
		:> endif	
		:> if [ not is_empty(prop.default) ] then begin
		${prop_value(prop.default)},
		:> else
		0,
		:> endif
		${prop_flags(prop)}|G_PARAM_STATIC_STRINGS	
		);
			:> PropType.FLOAT)
	${class_prefix}_properties[${PROP_NAME(prop)}] = g_param_spec_float (
		"${prop.name}",
		"${prop.name}",
		"${literal_trim(prop.description)}",
		:> if [ not is_empty(prop.min) ] then begin
		${prop_value(prop.min)},
		:> else
		G_MINFLOAT,
		:> endif	
		:> if [ not is_empty(prop.max) ] then begin
		${prop_value(prop.max)},
		:> else
		G_MAXFLOAT,
		:> endif	
		:> if [ not is_empty(prop.default) ] then begin
		${prop_value(prop.default)},
		:> else
		0,
		:> endif
		${prop_flags(prop)}|G_PARAM_STATIC_STRINGS	
		);
			:> PropType.DOUBLE)
	${class_prefix}_properties[${PROP_NAME(prop)}] = g_param_spec_double (
		"${prop.name}",
		"${prop.name}",
		"${literal_trim(prop.description)}",
		:> if [ not is_empty(prop.min) ] then begin
		${prop_value(prop.min)},
		:> else
		G_MINDOUBLE,
		:> endif	
		:> if [ not is_empty(prop.max) ] then begin
		${prop_value(prop.max)},
		:> else
		G_MAXDOUBLE,
		:> endif	
		:> if [ not is_empty(prop.default) ] then begin
		${prop_value(prop.default)},
		:> else
		0,
		:> endif
		${prop_flags(prop)}|G_PARAM_STATIC_STRINGS	
		);
			:> PropType.STRING)
	${class_prefix}_properties[${PROP_NAME(prop)}] = g_param_spec_string (
		"${prop.name}",
		"${prop.name}",
		"${literal_trim(prop.description)}",
		:> if [ not is_empty(prop.default) ] then begin
		${prop_value(prop.default)},
		:> else
		"",
		:> endif
		${prop_flags(prop)}|G_PARAM_STATIC_STRINGS
		);
			:> PropType.POINTER)
	${class_prefix}_properties[${PROP_NAME(prop)}] = g_param_spec_pointer (
		"${prop.name}",
		"${prop.name}",
		"${literal_trim(prop.description)}",
		${prop_flags(prop)}|G_PARAM_STATIC_STRINGS
		);
			:> PropType.OBJECT)
	${class_prefix}_properties[${PROP_NAME(prop)}] = g_param_spec_object (
		"${prop.name}",
		"${prop.name}",
		"${literal_trim(prop.description)}",
		${prop_gtype(prop.gtype)},
		${prop_flags(prop)}|G_PARAM_STATIC_STRINGS
		);
			:> PropType.ENUMERATION)
	${class_prefix}_properties[${PROP_NAME(prop)}] = g_param_spec_enum (
		"${prop.name}",
		"${prop.name}",
		"${literal_trim(prop.description)}",
		${prop_gtype(prop.gtype)},
		${prop_value(prop.default)},
		${prop_flags(prop)}|G_PARAM_STATIC_STRINGS
		);			
		:> endcase
	:> endedit
	
	:> done
	
	g_object_class_install_properties (gobj_class,
		NUM_PROPERTIES,
		${class_prefix}_properties
		);

:> endif

:> if [ class.has_signals() ] then begin

	:> for each signal in class.get_signals() do
	
		:> define input_params = signal.get_input_params()
		:> define num_input_params = length(input_params)
	
		:> if [ isFirst ] then begin
	/* signals */
		
		:> endif
		
	closure = g_cclosure_new (
		G_CALLBACK (${class_prefix}_class->${signal_tech_name(signal)}), 
		NULL, 
		NULL
		);
	
	${class_prefix}_signals[SIGNAL_${to_upper(signal_tech_name(signal))}] = ${class_prefix}_register_signal (
		"${signal.name}",
		closure,
		(GSignalCMarshaller) ${marshaller_func(signal)},
		G_TYPE_NONE, /* return type */
		:> if [ num_input_params > 0 ] then begin
		${num_input_params},
			:> for each input_param in input_params do
				:> if [ not isLast ] then begin
		${TYPE_MACRO(input_param.type)},
				:> else
		${TYPE_MACRO(input_param.type)}
				:> endif
			:> done
		:> else
		${num_input_params}
		:> endif
		);
	
	:> done

:> endif

:> edit-section 'class-init' begin
/* Add custom class initialization code ... */
:> endedit

}

static void
${class_prefix}_instance_init (
	GTypeInstance *instance,
	gpointer klass)
{

	${FullClassName} *self = ${CAST_MACRO(class)} (instance);

:> if [ hasPrivAttrs ] then begin
	self->priv = ${CAST_MACRO(class)}_GET_PRIVATE (self);
:> endif

:> edit-section 'instance-init' begin
/* Add custom instance initialization code ... */
:> endedit

}

GObject *
${class_prefix}_constructor (
	GType gtype,
	guint num_properties,
	GObjectConstructParam *properties
	) 
{

	/* call parent's constructor first: */ 
	GObject *new_obj = G_OBJECT_CLASS (${class_prefix}_parent_class)->constructor (
		gtype, 
		num_properties,
		properties);

:> edit-section 'constructor' begin
/* Add custom constructor code ... */
:> endedit

	return new_obj;

}

GType 
${class_prefix}_get_type (void) 
{
	static GType type = 0;
	
	if (type == 0) 
	{
		const GTypeInfo type_info = {
	   		sizeof (${FullClassName}Class),
	   		(GBaseInitFunc) ${class_prefix}_base_init,
	   		(GBaseFinalizeFunc) ${class_prefix}_base_finalize,
	   		(GClassInitFunc) ${class_prefix}_class_init,
	   		NULL, /* class finalizer */
	   		NULL, /* class_data */
	   		sizeof (${FullClassName}),
	   		0, /* n_preallocs */
	   		(GInstanceInitFunc) ${class_prefix}_instance_init
	   		};
    		
		:> if [ is_empty(class.super_class) ] then begin
		type = g_type_register_static (G_TYPE_OBJECT,
		:> else
		type = g_type_register_static (${TYPE_MACRO(class.super_class)},
		:> endif
			"${FullClassName}",
			&type_info,
			:> if [ class.is_abstract ] then begin
			G_TYPE_FLAG_ABSTRACT);
			:> else
			0);	
			:> endif
	}

	return type;
}

:> if [ not class.is_abstract ] then begin
/* 
 * constructor: 
 */
${FullClassName} *
	:> if [ not is_empty(class.constructor) ] then begin
${class_prefix}_new (${method_signature(class, class.constructor, supress_param_names, insert_line_breaks, indent_level)})
	:> else
${class_prefix}_new (void)
	:> endif
{

	${FullClassName} *new_instance = NULL;
	
	:> define constructor = class.constructor
	:> define doneConstructor = FALSE
	
	:> if [ not is_empty(constructor) ] then begin
		:> for each param in constructor.parameters where \
			not is_empty(param.bind_to_property) \
			do
			:> if [isFirst] then begin
	new_instance = ${CAST_MACRO(class)} (g_object_new (${TYPE_MACRO(class)},
				:> doneConstructor = TRUE
			:> endif
		"${param.bind_to_property}", ${param.name},
		:> done
		:> for each prop_init in constructor.prop_inits do
			:> if [isFirst and not doneConstructor] then begin
	new_instance = ${CAST_MACRO(class)} (g_object_new (${TYPE_MACRO(class)},
				:> doneConstructor = TRUE
			:> endif
		"${prop_init.name}", ${prop_value(prop_init.value)},
		:> done
	:> endif
	:> if [doneConstructor] then begin
		NULL));
	:> else
	new_instance = ${CAST_MACRO(class)} (g_object_new (${TYPE_MACRO(class)}, NULL));
	:> endif
	
	:> edit-section 'new' begin
	/* your instance initialization code ... */
	:> endedit
	
	return new_instance;

}
:> endif

:> if [ not class.is_final and not is_empty(class.constructor) ] then begin

	:> define cparams = class.constructor.parameters 
	:> case length(cparams) in
		:> 1)
void
${class_prefix}_initialize_ (${FullClassName} *self)
		:> 2)
void
${class_prefix}_initialize_ (
	${FullClassName} *self, 
	${method_signature(class, class.constructor, supress_param_names, insert_line_breaks, indent_level)}
	)
		:> *)		
void
${class_prefix}_initialize_ (
	${FullClassName} *self, ${method_signature(class, class.constructor, supress_param_names, insert_line_breaks, indent_level)})	
	:> endcase
{
	:> edit-section 'initialize_' begin
	/* initialize ... */
	:> endedit
}
:> endif

static void
${class_prefix}_dispose (GObject* obj) 
{
	:> edit-section 'dispose' begin
	/* 
	 * In dispose, you are supposed to free all types referenced from this
 	 * object which might themselves hold a reference to self. Generally,
 	 * the most simple solution is to unref all members on which you own a 
 	 * reference.
 	 */	
	:> endedit
	
	/* chain up to super class: */
	G_OBJECT_CLASS (${class_prefix}_parent_class)->dispose (obj);

}

static void
${class_prefix}_finalize (GObject* obj)
{
	:> edit-section 'finalize' begin
	/* Free allocated memory here ... */
	:> endedit

	/* chain up to super class: */
	G_OBJECT_CLASS (${class_prefix}_parent_class)->finalize (obj);

}

:> if [ not is_empty(class.get_properties()) ] then begin

static void
${class_prefix}_set_property (
	GObject      *object,
	guint        property_id,
	const GValue *value,
	GParamSpec   *pspec
	)
{

:> define hasSetters = FALSE
:> for each prop in class.get_properties() where prop.is_writable() do

	:> if [isFirst] then begin
	:> edit-section 'set_property' begin
	/* your variable declarations...*/
	:> endedit
	
		:> hasSetters = TRUE
	switch (property_id) 
	{
	:> endif
	case ${PROP_NAME(prop)}:
		:> define section_name = prop_setter_section(prop) 
		:> edit-section section_name begin
		g_warning("Class '%s': Setter for property '%s' is not implemented", "${FullClassName}", "${prop.name}");  
		:> endedit
		break;
	:> if [isLast] then begin
	default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
	:> endif

:> done

:> if [ not hasSetters ] then begin
	G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
:> endif

}
	
static void
${class_prefix}_get_property (
	GObject    *object,
	guint      property_id,
	GValue     *value,
	GParamSpec *pspec
	)
{

:> define hasGetters = FALSE
:> for each prop in class.get_properties() where prop.is_readable() do

	:> if [isFirst] then begin
	:> edit-section 'get_property' begin
	/* your variable declarations...*/
	:> endedit
	
		:> hasGetters = TRUE
	switch (property_id) 
	{
	:> endif
	case ${PROP_NAME(prop)}:
		:> define section_name = prop_getter_section(prop) 
		:> edit-section section_name begin
		g_warning("Class '%s': Getter for property '%s' is not implemented", "${FullClassName}", "${prop.name}");
		:> endedit
		break;
	:> if [isLast] then begin
	default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
	:> endif
:> done

:> if [ not hasGetters ] then begin
	G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
:> endif

}

:> endif
